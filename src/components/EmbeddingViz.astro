---
/**
 * EmbeddingViz.astro — 3D rotating word embedding space
 *
 * Canvas-based 3D point cloud showing word embeddings in "meaning space."
 * Clusters of semantically similar words with constellation-like connections,
 * plus the Paris-France / Tokyo-Japan vector analogy showing how directions
 * encode relationships.
 *
 * Auto-rotates gently around the Y axis. Drag to rotate manually.
 * IntersectionObserver starts/stops animation when off-screen.
 */
---

<section class="embed-section" id="embedding-viz-section" aria-label="Word embeddings 3D visualization">
  <div class="embed-container">
    <div class="embed-text-content" data-embed="text">
      <h2 class="embed-heading">Meaning Space</h2>
      <p class="embed-desc">
        Every word becomes a point in this space. As the model trains on billions
        of sentences, it learns to place words that appear in similar contexts near
        each other. The result is a rich geometric landscape where relationships
        between words are captured as <strong>directions</strong> and
        <strong>distances</strong>.
      </p>
    </div>

    <div class="embed-canvas-wrap" data-embed="canvas-wrap">
      <canvas id="embedding-canvas"
        role="img"
        aria-label="3D rotating visualization of word embedding space showing clusters of similar words: places like Paris, Tokyo, London; animals like dog, cat, puppy; emotions like happy, sad, love; and science terms like atom, cell, DNA. The direction from France to Paris is the same as from Japan to Tokyo, encoding the capital-of relationship."
      ></canvas>
    </div>

    <div class="embed-legend" data-embed="legend">
      <span class="embed-legend-item">
        <span class="embed-legend-dot" style="background: #38bdf8"></span>Places
      </span>
      <span class="embed-legend-item">
        <span class="embed-legend-dot" style="background: #34d399"></span>Animals
      </span>
      <span class="embed-legend-item">
        <span class="embed-legend-dot" style="background: #fb7185"></span>Emotions
      </span>
      <span class="embed-legend-item">
        <span class="embed-legend-dot" style="background: #a78bfa"></span>Science
      </span>
    </div>

    <div class="embed-analogy-wrap" data-embed="analogy">
      <p class="embed-formula">Paris &minus; France + Japan &asymp; Tokyo</p>
      <p class="embed-analogy-explain">
        The direction from France to Paris encodes the concept <em>"capital of."</em>
        Apply that same direction starting from Japan and you land near Tokyo. The model
        discovers these geometric relationships entirely on its own, by predicting which
        words appear in similar contexts across billions of sentences.
      </p>
      <p class="embed-cite">
        First demonstrated by Mikolov et al. (2013) with Word2Vec. Modern LLMs use
        <strong>contextual embeddings</strong> where a word's position shifts depending on
        the sentence around it — "bank" moves toward finance or rivers depending on context.
      </p>
    </div>
  </div>
</section>

<style>
  .embed-section {
    position: relative;
    width: 100%;
    padding: 2rem 1.5rem 4rem;
  }

  .embed-container {
    max-width: 800px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1.5rem;
  }

  .embed-text-content {
    text-align: center;
    max-width: 640px;
  }

  .embed-heading {
    font-size: clamp(1.4rem, 3.5vw, 2rem);
    font-weight: 700;
    color: #1a2e3a;
    margin: 0 0 0.75rem;
    letter-spacing: -0.02em;
  }

  .embed-desc {
    font-size: clamp(0.9rem, 2vw, 1.05rem);
    color: #3d5a6a;
    line-height: 1.7;
    margin: 0;
  }

  .embed-desc strong {
    color: #0369a1;
  }

  /* Canvas wrapper */
  .embed-canvas-wrap {
    width: 100%;
    max-width: 700px;
    aspect-ratio: 5 / 4;
    border-radius: 12px;
    overflow: hidden;
    background: rgba(230, 240, 245, 0.9);
    border: 1px solid rgba(8, 145, 178, 0.15);
  }

  #embedding-canvas {
    display: block;
    width: 100%;
    height: 100%;
    cursor: grab;
  }

  #embedding-canvas:active {
    cursor: grabbing;
  }

  /* Legend */
  .embed-legend {
    display: flex;
    gap: 1.5rem;
    flex-wrap: wrap;
    justify-content: center;
  }

  .embed-legend-item {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    font-size: 0.8rem;
    color: #3d5a6a;
    font-family: 'Inter', system-ui, sans-serif;
  }

  .embed-legend-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  /* Analogy */
  .embed-analogy-wrap {
    max-width: 600px;
    text-align: center;
  }

  .embed-formula {
    font-size: 1.15rem;
    font-weight: 600;
    color: #1a2e3a;
    padding: 0.75rem 1.25rem;
    background: rgba(8, 145, 178, 0.06);
    border: 1px solid rgba(8, 145, 178, 0.2);
    border-radius: 8px;
    font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
    letter-spacing: 0.02em;
    margin: 0 0 1rem;
  }

  .embed-analogy-explain {
    font-size: 0.95rem;
    color: #3d5a6a;
    line-height: 1.7;
    margin: 0 0 0.75rem;
  }

  .embed-analogy-explain em {
    color: #0369a1;
    font-style: italic;
  }

  .embed-cite {
    font-size: 0.85rem;
    font-style: italic;
    color: #5a7a8a;
    padding-left: 1rem;
    border-left: 2px solid rgba(8, 145, 178, 0.25);
    text-align: left;
    margin: 0;
  }

  .embed-cite strong {
    color: #3d5a6a;
    font-weight: 600;
  }

  @media (max-width: 640px) {
    .embed-section {
      padding: 1.5rem 1rem 3rem;
    }
    .embed-legend {
      gap: 1rem;
    }
  }
</style>

<script>
  function initEmbeddingViz() {
    const canvas = document.getElementById('embedding-canvas') as HTMLCanvasElement;
    const section = document.getElementById('embedding-viz-section');
    if (!canvas || !section) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // --- Cluster colors ---
    const clusterColors: Record<string, string> = {
      places: '#38bdf8',
      animals: '#34d399',
      emotions: '#fb7185',
      science: '#a78bfa',
    };

    // --- 3D word positions ---
    // Paris-France vector = (40, -30, 30); Japan + that = Tokyo ✓
    const points3D = [
      // Places (cyan)
      { word: 'Paris',   x: -120, y: -65,  z: 65,   cluster: 'places' },
      { word: 'France',  x: -170, y: -26,  z: 26,   cluster: 'places' },
      { word: 'Tokyo',   x: -65,  y: -90,  z: -65,  cluster: 'places' },
      { word: 'Japan',   x: -120, y: -52,  z: -104, cluster: 'places' },
      { word: 'London',  x: -145, y: -78,  z: 13,   cluster: 'places' },
      { word: 'England', x: -195, y: -39,  z: -26,  cluster: 'places' },

      // Animals (green)
      { word: 'dog',    x: 130,  y: 65,   z: -39,  cluster: 'animals' },
      { word: 'puppy',  x: 90,   y: 104,  z: -13,  cluster: 'animals' },
      { word: 'cat',    x: 170,  y: 78,   z: 39,   cluster: 'animals' },
      { word: 'kitten', x: 130,  y: 117,  z: 65,   cluster: 'animals' },
      { word: 'bird',   x: 90,   y: 39,   z: -65,  cluster: 'animals' },

      // Emotions (pink)
      { word: 'happy', x: -39,  y: 130,  z: 104,  cluster: 'emotions' },
      { word: 'sad',   x: 13,   y: 156,  z: 65,   cluster: 'emotions' },
      { word: 'angry', x: -13,  y: 117,  z: 143,  cluster: 'emotions' },
      { word: 'love',  x: -65,  y: 143,  z: 52,   cluster: 'emotions' },

      // Science (purple)
      { word: 'atom', x: 143,  y: -130, z: 52,   cluster: 'science' },
      { word: 'cell', x: 104,  y: -104, z: 26,   cluster: 'science' },
      { word: 'gene', x: 130,  y: -143, z: 78,   cluster: 'science' },
      { word: 'DNA',  x: 170,  y: -117, z: 104,  cluster: 'science' },
    ];

    // Analogy arrows: France→Paris (solid), Japan→Tokyo (dashed)
    const analogyPairs = [
      { from: 'France', to: 'Paris', dashed: false },
      { from: 'Japan',  to: 'Tokyo', dashed: true },
    ];

    // --- Animation state ---
    let rotY = 0;
    let animId: number | null = null;
    let w = 0;
    let h = 0;
    let cx = 0;
    let cy = 0;
    let isVisible = false;
    let isDragging = false;
    let dragStartX = 0;
    let dragRotStart = 0;
    const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const autoSpeed = prefersReduced ? 0 : 0.003;

    // --- Canvas setup ---
    function resize() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      w = rect.width;
      h = rect.height;
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      cx = w / 2;
      cy = h / 2;
    }

    // --- 3D → 2D perspective projection ---
    function project(x: number, y: number, z: number) {
      const cosR = Math.cos(rotY);
      const sinR = Math.sin(rotY);
      const rx = x * cosR - z * sinR;
      const rz = x * sinR + z * cosR;
      const fov = 500;
      const s = fov / (fov + rz);
      return {
        sx: rx * s + cx,
        sy: -y * s + cy,  // flip Y: positive = up
        scale: s,
        rz,
      };
    }

    // --- Draw perspective grid at y=0 ---
    function drawGrid() {
      ctx.beginPath();
      const lines = [-200, -100, 0, 100, 200];
      const ext = 250;

      for (const gz of lines) {
        const a = project(-ext, 0, gz);
        const b = project(ext, 0, gz);
        ctx.moveTo(a.sx, a.sy);
        ctx.lineTo(b.sx, b.sy);
      }
      for (const gx of lines) {
        const a = project(gx, 0, -ext);
        const b = project(gx, 0, ext);
        ctx.moveTo(a.sx, a.sy);
        ctx.lineTo(b.sx, b.sy);
      }

      ctx.strokeStyle = 'rgba(0, 50, 80, 0.08)';
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    // --- Draw constellation lines within clusters ---
    function drawClusterLinks(proj: any[]) {
      const clusters = Object.keys(clusterColors);

      for (const cluster of clusters) {
        const pts = proj.filter((p: any) => p.cluster === cluster);
        const color = clusterColors[cluster];

        for (let i = 0; i < pts.length; i++) {
          for (let j = i + 1; j < pts.length; j++) {
            const a = pts[i];
            const b = pts[j];
            const avgZ = (a.rz + b.rz) / 2;
            const alpha = Math.max(0.03, Math.min(0.12, 0.08 - avgZ * 0.0002));

            ctx.beginPath();
            ctx.moveTo(a.sx, a.sy);
            ctx.lineTo(b.sx, b.sy);
            ctx.strokeStyle = color;
            ctx.globalAlpha = alpha;
            ctx.lineWidth = 0.8;
            ctx.stroke();
          }
        }
      }
      ctx.globalAlpha = 1;
    }

    // --- Draw analogy arrows + parallelogram ---
    function drawAnalogy(proj: any[]) {
      const find = (name: string) => proj.find((p: any) => p.word === name);

      for (const pair of analogyPairs) {
        const from = find(pair.from);
        const to = find(pair.to);
        if (!from || !to) continue;

        const avgZ = (from.rz + to.rz) / 2;
        const alpha = Math.max(0.25, Math.min(0.75, 0.55 - avgZ * 0.001));

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = '#00d4ff';
        ctx.lineWidth = 2;

        if (pair.dashed) ctx.setLineDash([6, 4]);
        else ctx.setLineDash([]);

        ctx.beginPath();
        ctx.moveTo(from.sx, from.sy);
        ctx.lineTo(to.sx, to.sy);
        ctx.stroke();
        ctx.setLineDash([]);

        // Arrowhead
        const angle = Math.atan2(to.sy - from.sy, to.sx - from.sx);
        const hl = 8;
        ctx.beginPath();
        ctx.moveTo(to.sx, to.sy);
        ctx.lineTo(to.sx - hl * Math.cos(angle - 0.35), to.sy - hl * Math.sin(angle - 0.35));
        ctx.lineTo(to.sx - hl * Math.cos(angle + 0.35), to.sy - hl * Math.sin(angle + 0.35));
        ctx.closePath();
        ctx.fillStyle = '#00d4ff';
        ctx.fill();

        ctx.restore();
      }

      // Parallelogram connectors (thin dotted)
      const france = find('France');
      const japan = find('Japan');
      const paris = find('Paris');
      const tokyo = find('Tokyo');
      if (france && japan && paris && tokyo) {
        ctx.save();
        ctx.setLineDash([2, 4]);
        ctx.strokeStyle = 'rgba(0, 50, 80, 0.15)';
        ctx.lineWidth = 1;

        ctx.beginPath();
        ctx.moveTo(france.sx, france.sy);
        ctx.lineTo(japan.sx, japan.sy);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(paris.sx, paris.sy);
        ctx.lineTo(tokyo.sx, tokyo.sy);
        ctx.stroke();

        ctx.setLineDash([]);
        ctx.restore();
      }
    }

    // --- Draw a single point with glow + label ---
    function drawPoint(p: any) {
      const color = clusterColors[p.cluster] || '#38bdf8';
      const r = 7 * p.scale;
      const alpha = Math.max(0.3, Math.min(1.0, 0.7 - p.rz * 0.0015));

      ctx.save();

      // Glow
      ctx.globalAlpha = alpha * 0.18;
      ctx.beginPath();
      ctx.arc(p.sx, p.sy, r * 2.5, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();

      // Core dot
      ctx.globalAlpha = alpha * 0.9;
      ctx.beginPath();
      ctx.arc(p.sx, p.sy, r, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();

      // Label
      ctx.globalAlpha = alpha * 0.9;
      const fontSize = Math.max(10, 13 * p.scale);
      ctx.font = `600 ${fontSize}px Inter, system-ui, sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillStyle = 'rgba(26, 46, 58, 0.9)';
      ctx.fillText(p.word, p.sx, p.sy - r - 7);

      ctx.restore();
    }

    // --- Main render ---
    function render() {
      ctx.clearRect(0, 0, w, h);

      drawGrid();

      // Project all points
      const proj = points3D.map(p => {
        const pr = project(p.x, p.y, p.z);
        return { ...p, ...pr };
      });

      // Depth sort: far (high rz) drawn first
      proj.sort((a, b) => b.rz - a.rz);

      drawClusterLinks(proj);
      drawAnalogy(proj);
      proj.forEach(p => drawPoint(p));

      if (!isDragging) rotY += autoSpeed;

      if (isVisible) {
        animId = requestAnimationFrame(render);
      }
    }

    // --- Start / stop ---
    function start() {
      if (animId) return;
      isVisible = true;
      resize();
      render();
    }

    function stop() {
      isVisible = false;
      if (animId) {
        cancelAnimationFrame(animId);
        animId = null;
      }
    }

    // --- Drag interaction (mouse) ---
    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      dragStartX = e.clientX;
      dragRotStart = rotY;
    });
    window.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      rotY = dragRotStart + (e.clientX - dragStartX) * 0.005;
    });
    window.addEventListener('mouseup', () => { isDragging = false; });

    // --- Drag interaction (touch) ---
    canvas.addEventListener('touchstart', (e) => {
      isDragging = true;
      dragStartX = e.touches[0].clientX;
      dragRotStart = rotY;
    }, { passive: true });
    window.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
      rotY = dragRotStart + (e.touches[0].clientX - dragStartX) * 0.005;
    }, { passive: true });
    window.addEventListener('touchend', () => { isDragging = false; });

    // --- Visibility observer ---
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) start();
          else stop();
        });
      },
      { threshold: 0.1 },
    );
    observer.observe(section);

    // --- Resize ---
    window.addEventListener('resize', () => { if (isVisible) resize(); });

    // --- GSAP text fade-ins ---
    const gsap = (window as any).gsap;
    const ScrollTrigger = (window as any).ScrollTrigger;
    if (gsap && ScrollTrigger) {
      const text = section.querySelector('[data-embed="text"]');
      const wrap = section.querySelector('[data-embed="canvas-wrap"]');
      const legend = section.querySelector('[data-embed="legend"]');
      const analogy = section.querySelector('[data-embed="analogy"]');

      gsap.from(text, {
        opacity: 0, y: 20, duration: 0.6,
        scrollTrigger: { trigger: section, start: 'top 80%', toggleActions: 'play none none reverse' },
      });
      gsap.from(wrap, {
        opacity: 0, y: 15, duration: 0.6,
        scrollTrigger: { trigger: section, start: 'top 75%', toggleActions: 'play none none reverse' },
      });
      gsap.from(legend, {
        opacity: 0, duration: 0.4,
        scrollTrigger: { trigger: section, start: 'top 70%', toggleActions: 'play none none reverse' },
      });
      gsap.from(analogy, {
        opacity: 0, y: 15, duration: 0.6,
        scrollTrigger: { trigger: section, start: 'top 65%', toggleActions: 'play none none reverse' },
      });
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initEmbeddingViz);
  } else {
    initEmbeddingViz();
  }
</script>
