---
/**
 * NeuralNetworkSVG.astro
 *
 * A simplified but accurate transformer architecture diagram.
 * Shows: Input tokens -> Embedding -> N x (Self-Attention + Feed-Forward) -> Output -> Softmax -> Next token
 *
 * Features:
 * - "Black box" effect: starts opaque, reveals internals on scroll
 * - Animated data-flow pulses along connection paths
 * - Clear layer labeling with accurate transformer terminology
 * - All inline SVG, GSAP-triggerable via data attributes and IDs
 */
---

<section id="neural-network-section" class="nn-section" aria-label="Neural network transformer architecture">
  <div class="nn-container">
    <div class="nn-text-content">
      <h2 class="nn-heading" data-nn="heading">The LLM: a black box?</h2>
      <p class="nn-description" data-nn="desc">
        GPT-4 has an estimated <strong>1.8 trillion parameters</strong> &mdash; numerical
        values learned during training. That&rsquo;s why it&rsquo;s called a &ldquo;black box&rdquo;:
        no human could unravel all those connections. But we <em>can</em>
        understand the architecture. Let&rsquo;s open the box.
      </p>
    </div>

    <div class="nn-layout" data-nn="layout">
    <div class="nn-viz-wrapper" data-nn="viz-wrapper">
      <!-- SVG circle mask overlay -->
      <div class="nn-blackbox-overlay" data-nn="blackbox" aria-hidden="true">
        <svg class="nn-mask-svg" viewBox="0 0 900 560" preserveAspectRatio="xMidYSlice meet">
          <defs>
            <mask id="nn-reveal-mask" maskUnits="userSpaceOnUse" x="0" y="0" width="900" height="560">
              <rect width="900" height="560" fill="white"/>
              <circle id="nn-reveal-circle" cx="450" cy="280" r="0" fill="black"/>
            </mask>
            <radialGradient id="nn-mask-edge-grad">
              <stop offset="85%" stop-color="black"/>
              <stop offset="100%" stop-color="white"/>
            </radialGradient>
          </defs>
          <!-- Dark overlay with circle cut out -->
          <rect width="900" height="560" fill="rgba(225, 238, 243, 0.97)" mask="url(#nn-reveal-mask)"/>
        </svg>
        <span class="nn-blackbox-label" data-nn="blackbox-label">?</span>
      </div>

      <svg
        id="nn-svg"
        class="nn-svg"
        viewBox="0 0 900 560"
        xmlns="http://www.w3.org/2000/svg"
        role="img"
        aria-label="Transformer architecture diagram showing input tokens flowing through embedding, self-attention, feed-forward layers, and output softmax to produce next-token predictions"
      >
        <defs>
          <!-- Glow filter for nodes -->
          <filter id="nn-glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
          </filter>

          <!-- Stronger glow for active pulses -->
          <filter id="nn-pulse-glow" x="-100%" y="-100%" width="300%" height="300%">
            <feGaussianBlur in="SourceGraphic" stdDeviation="6" result="blur" />
            <feMerge>
              <feMergeNode in="blur" />
              <feMergeNode in="SourceGraphic" />
            </feMerge>
          </filter>

          <!-- Gradient for connection lines -->
          <linearGradient id="nn-conn-grad" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" stop-color="#0ea5e9" stop-opacity="0.15" />
            <stop offset="50%" stop-color="#0ea5e9" stop-opacity="0.4" />
            <stop offset="100%" stop-color="#0ea5e9" stop-opacity="0.15" />
          </linearGradient>

          <!-- Gradient for attention block -->
          <linearGradient id="nn-attn-grad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" stop-color="#0ea5e9" stop-opacity="0.12" />
            <stop offset="100%" stop-color="#06b6d4" stop-opacity="0.06" />
          </linearGradient>

          <!-- Gradient for FFN block -->
          <linearGradient id="nn-ffn-grad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" stop-color="#8b5cf6" stop-opacity="0.12" />
            <stop offset="100%" stop-color="#7c3aed" stop-opacity="0.06" />
          </linearGradient>

          <!-- Data flow pulse gradient -->
          <radialGradient id="nn-data-pulse">
            <stop offset="0%" stop-color="#00d4ff" stop-opacity="1" />
            <stop offset="60%" stop-color="#0ea5e9" stop-opacity="0.6" />
            <stop offset="100%" stop-color="#0ea5e9" stop-opacity="0" />
          </radialGradient>

          <!-- Arrow marker -->
          <marker id="nn-arrow" viewBox="0 0 10 10" refX="9" refY="5"
            markerWidth="6" markerHeight="6" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="#0ea5e9" opacity="0.5" />
          </marker>
        </defs>

        <!-- ===== LAYER 1: INPUT TOKENS ===== -->
        <g data-nn-layer="input" class="nn-layer" opacity="0">
          <text x="400" y="538" class="nn-layer-label" text-anchor="middle">Input</text>
          <text x="400" y="552" class="nn-layer-sublabel" text-anchor="middle">Tokens</text>

          <g class="nn-token-group">
            <rect x="275" y="492" width="50" height="30" rx="4" class="nn-token-box" data-nn-node="input-0" />
            <text x="300" y="512" class="nn-token-text" text-anchor="middle">The</text>
          </g>
          <g class="nn-token-group">
            <rect x="375" y="492" width="50" height="30" rx="4" class="nn-token-box" data-nn-node="input-1" />
            <text x="400" y="512" class="nn-token-text" text-anchor="middle">cat</text>
          </g>
          <g class="nn-token-group">
            <rect x="475" y="492" width="50" height="30" rx="4" class="nn-token-box" data-nn-node="input-2" />
            <text x="500" y="512" class="nn-token-text" text-anchor="middle">sat</text>
          </g>
        </g>

        <!-- ===== LAYER 2: EMBEDDING ===== -->
        <g data-nn-layer="embedding" class="nn-layer" opacity="0">
          <text x="400" y="454" class="nn-layer-label" text-anchor="middle">Embedding</text>

          <circle cx="300" cy="466" r="10" class="nn-node nn-node-embed" data-nn-node="embed-0" />
          <circle cx="400" cy="466" r="10" class="nn-node nn-node-embed" data-nn-node="embed-1" />
          <circle cx="500" cy="466" r="10" class="nn-node nn-node-embed" data-nn-node="embed-2" />

          <line x1="300" y1="492" x2="300" y2="476" class="nn-connection" data-nn-conn="input-embed" />
          <line x1="400" y1="492" x2="400" y2="476" class="nn-connection" data-nn-conn="input-embed" />
          <line x1="500" y1="492" x2="500" y2="476" class="nn-connection" data-nn-conn="input-embed" />
        </g>

        <!-- ===== TRANSFORMER BLOCK 1 ===== -->
        <g data-nn-layer="transformer-1" class="nn-layer nn-transformer-block" opacity="0">
          <rect x="180" y="276" width="440" height="168" rx="8" class="nn-block-bg" />
          <text x="632" y="340" class="nn-block-label">Transformer</text>
          <text x="632" y="358" class="nn-block-label">Block 1</text>

          <!-- Self-Attention sub-block: label at top, nodes below -->
          <rect x="195" y="358" width="410" height="76" rx="6" class="nn-attn-block" />
          <text x="400" y="376" class="nn-sublayer-label" text-anchor="middle">Self-Attention</text>

          <circle cx="300" cy="414" r="8" class="nn-node nn-node-attn" data-nn-node="attn1-0" />
          <circle cx="400" cy="414" r="8" class="nn-node nn-node-attn" data-nn-node="attn1-1" />
          <circle cx="500" cy="414" r="8" class="nn-node nn-node-attn" data-nn-node="attn1-2" />

          <line x1="300" y1="414" x2="400" y2="414" class="nn-attention-link" />
          <line x1="400" y1="414" x2="500" y2="414" class="nn-attention-link" />
          <line x1="300" y1="414" x2="500" y2="414" class="nn-attention-link" />

          <!-- Feed-Forward sub-block: label at top, nodes below -->
          <rect x="195" y="282" width="410" height="66" rx="6" class="nn-ffn-block" />
          <text x="400" y="302" class="nn-sublayer-label" text-anchor="middle">Feed-Forward (MLP)</text>

          <circle cx="270" cy="332" r="8" class="nn-node nn-node-ffn" data-nn-node="ffn1-0" />
          <circle cx="360" cy="332" r="8" class="nn-node nn-node-ffn" data-nn-node="ffn1-1" />
          <circle cx="450" cy="332" r="8" class="nn-node nn-node-ffn" data-nn-node="ffn1-2" />
          <circle cx="540" cy="332" r="8" class="nn-node nn-node-ffn" data-nn-node="ffn1-3" />

          <!-- Internal connections: attention -> FFN -->
          <line x1="300" y1="406" x2="270" y2="340" class="nn-connection nn-internal" />
          <line x1="300" y1="406" x2="360" y2="340" class="nn-connection nn-internal" />
          <line x1="400" y1="406" x2="360" y2="340" class="nn-connection nn-internal" />
          <line x1="400" y1="406" x2="450" y2="340" class="nn-connection nn-internal" />
          <line x1="500" y1="406" x2="450" y2="340" class="nn-connection nn-internal" />
          <line x1="500" y1="406" x2="540" y2="340" class="nn-connection nn-internal" />

          <!-- Connections from embedding to attention -->
          <line x1="300" y1="456" x2="300" y2="422" class="nn-connection" data-nn-conn="embed-attn1" />
          <line x1="400" y1="456" x2="400" y2="422" class="nn-connection" data-nn-conn="embed-attn1" />
          <line x1="500" y1="456" x2="500" y2="422" class="nn-connection" data-nn-conn="embed-attn1" />
        </g>

        <!-- ===== TRANSFORMER BLOCK 2 ===== -->
        <g data-nn-layer="transformer-2" class="nn-layer nn-transformer-block" opacity="0">
          <rect x="180" y="96" width="440" height="168" rx="8" class="nn-block-bg" />
          <text x="632" y="160" class="nn-block-label">Transformer</text>
          <text x="632" y="178" class="nn-block-label">Block 2</text>

          <rect x="195" y="178" width="410" height="76" rx="6" class="nn-attn-block" />
          <text x="400" y="196" class="nn-sublayer-label" text-anchor="middle">Self-Attention</text>

          <circle cx="300" cy="234" r="8" class="nn-node nn-node-attn" data-nn-node="attn2-0" />
          <circle cx="400" cy="234" r="8" class="nn-node nn-node-attn" data-nn-node="attn2-1" />
          <circle cx="500" cy="234" r="8" class="nn-node nn-node-attn" data-nn-node="attn2-2" />

          <line x1="300" y1="234" x2="400" y2="234" class="nn-attention-link" />
          <line x1="400" y1="234" x2="500" y2="234" class="nn-attention-link" />
          <line x1="300" y1="234" x2="500" y2="234" class="nn-attention-link" />

          <rect x="195" y="102" width="410" height="66" rx="6" class="nn-ffn-block" />
          <text x="400" y="122" class="nn-sublayer-label" text-anchor="middle">Feed-Forward (MLP)</text>

          <circle cx="270" cy="152" r="8" class="nn-node nn-node-ffn" data-nn-node="ffn2-0" />
          <circle cx="360" cy="152" r="8" class="nn-node nn-node-ffn" data-nn-node="ffn2-1" />
          <circle cx="450" cy="152" r="8" class="nn-node nn-node-ffn" data-nn-node="ffn2-2" />
          <circle cx="540" cy="152" r="8" class="nn-node nn-node-ffn" data-nn-node="ffn2-3" />

          <line x1="300" y1="226" x2="270" y2="160" class="nn-connection nn-internal" />
          <line x1="300" y1="226" x2="360" y2="160" class="nn-connection nn-internal" />
          <line x1="400" y1="226" x2="360" y2="160" class="nn-connection nn-internal" />
          <line x1="400" y1="226" x2="450" y2="160" class="nn-connection nn-internal" />
          <line x1="500" y1="226" x2="450" y2="160" class="nn-connection nn-internal" />
          <line x1="500" y1="226" x2="540" y2="160" class="nn-connection nn-internal" />

          <!-- Connections from block 1 FFN to block 2 attention -->
          <line x1="270" y1="276" x2="300" y2="242" class="nn-connection" data-nn-conn="ffn1-attn2" />
          <line x1="400" y1="276" x2="400" y2="242" class="nn-connection" data-nn-conn="ffn1-attn2" />
          <line x1="540" y1="276" x2="500" y2="242" class="nn-connection" data-nn-conn="ffn1-attn2" />
        </g>

        <!-- ===== Nx label ===== -->
        <g data-nn-layer="transformer-2" class="nn-layer" opacity="0">
          <text x="640" y="245" class="nn-nx-label">&times;N</text>
          <text x="640" y="263" class="nn-nx-sublabel">layers</text>
        </g>

        <!-- ===== OUTPUT LAYER ===== -->
        <g data-nn-layer="output" class="nn-layer" opacity="0">
          <line x1="270" y1="96" x2="300" y2="86" class="nn-connection" data-nn-conn="ffn2-output" />
          <line x1="360" y1="96" x2="370" y2="86" class="nn-connection" data-nn-conn="ffn2-output" />
          <line x1="450" y1="96" x2="440" y2="86" class="nn-connection" data-nn-conn="ffn2-output" />
          <line x1="540" y1="96" x2="510" y2="86" class="nn-connection" data-nn-conn="ffn2-output" />

          <rect x="250" y="50" width="300" height="36" rx="6" class="nn-output-block" />
          <text x="400" y="74" class="nn-sublayer-label nn-output-label" text-anchor="middle">Softmax &rarr; Next Token</text>

          <g class="nn-prob-group" data-nn="probs">
            <rect x="700" y="30" width="8" height="46" rx="2" class="nn-prob-bar" data-nn-prob="0" opacity="0" />
            <text x="704" y="88" class="nn-prob-text" text-anchor="middle" opacity="0">on</text>

            <rect x="730" y="55" width="8" height="21" rx="2" class="nn-prob-bar" data-nn-prob="1" opacity="0" />
            <text x="734" y="88" class="nn-prob-text" text-anchor="middle" opacity="0">by</text>

            <rect x="760" y="62" width="8" height="14" rx="2" class="nn-prob-bar" data-nn-prob="2" opacity="0" />
            <text x="764" y="88" class="nn-prob-text" text-anchor="middle" opacity="0">in</text>

            <rect x="790" y="66" width="8" height="10" rx="2" class="nn-prob-bar" data-nn-prob="3" opacity="0" />
            <text x="794" y="88" class="nn-prob-text" text-anchor="middle" opacity="0">at</text>

            <text x="745" y="22" class="nn-prob-heading" text-anchor="middle" opacity="0">Predicted next token</text>

            <line x1="550" y1="68" x2="690" y2="68" class="nn-connection nn-output-conn" marker-end="url(#nn-arrow)" opacity="0" />
          </g>
        </g>

        <!-- ===== DATA FLOW PULSES ===== -->
        <g data-nn="pulses" aria-hidden="true">
          <circle r="5" class="nn-pulse" data-nn-pulse="0" opacity="0" fill="url(#nn-data-pulse)" filter="url(#nn-pulse-glow)" />
          <circle r="5" class="nn-pulse" data-nn-pulse="1" opacity="0" fill="url(#nn-data-pulse)" filter="url(#nn-pulse-glow)" />
          <circle r="5" class="nn-pulse" data-nn-pulse="2" opacity="0" fill="url(#nn-data-pulse)" filter="url(#nn-pulse-glow)" />
        </g>
      </svg>
    </div>

    <!-- KEY / LEGEND -->
    <div class="nn-key" data-nn="key">
      <h3 class="nn-key-title">Architecture Key</h3>

      <div class="nn-key-item" data-nn-key="input">
        <div class="nn-key-dot nn-key-dot--input"></div>
        <div>
          <span class="nn-key-label">Input Tokens</span>
          <span class="nn-key-desc">Text broken into pieces the model can process</span>
        </div>
      </div>

      <div class="nn-key-item" data-nn-key="embedding">
        <div class="nn-key-dot nn-key-dot--embed"></div>
        <div>
          <span class="nn-key-label">Embedding</span>
          <span class="nn-key-desc">Each token becomes a vector of ~12,000 numbers</span>
        </div>
      </div>

      <div class="nn-key-item" data-nn-key="attention">
        <div class="nn-key-dot nn-key-dot--attn"></div>
        <div>
          <span class="nn-key-label">Self-Attention</span>
          <span class="nn-key-desc">Every word looks at every other word for context</span>
        </div>
      </div>

      <div class="nn-key-item" data-nn-key="ffn">
        <div class="nn-key-dot nn-key-dot--ffn"></div>
        <div>
          <span class="nn-key-label">Feed-Forward (MLP)</span>
          <span class="nn-key-desc">Dense neural network layers that transform representations</span>
        </div>
      </div>

      <div class="nn-key-item" data-nn-key="output">
        <div class="nn-key-dot nn-key-dot--output"></div>
        <div>
          <span class="nn-key-label">Softmax Output</span>
          <span class="nn-key-desc">Probability distribution over every possible next token</span>
        </div>
      </div>

      <div class="nn-key-callout" data-nn-key="params">
        <strong>GPT-4: ~1.8 trillion parameters</strong>
        <span>96 transformer layers, each with billions of learned numerical connections.
        This is why it&rsquo;s a &ldquo;black box&rdquo; &mdash; the sheer scale makes
        individual connections impossible to trace.</span>
      </div>
    </div>
    </div><!-- /nn-layout -->
  </div>
</section>

<style>
  .nn-section {
    position: relative;
    width: 100%;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 4rem 1.5rem;
  }

  .nn-container {
    max-width: 1100px;
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2.5rem;
  }

  .nn-text-content {
    text-align: center;
    max-width: 640px;
  }

  .nn-heading {
    font-size: clamp(1.6rem, 4vw, 2.4rem);
    font-weight: 700;
    color: #1a2e3a;
    margin: 0 0 1rem;
    letter-spacing: -0.02em;
    line-height: 1.2;
  }

  .nn-description {
    font-size: clamp(0.95rem, 2vw, 1.1rem);
    color: #3d5a6a;
    line-height: 1.7;
    margin: 0;
  }

  .nn-description em {
    color: #1a2e3a;
    font-style: italic;
  }

  /* === Side-by-side layout === */
  .nn-layout {
    display: grid;
    grid-template-columns: 1fr 280px;
    gap: 1.5rem;
    width: 100%;
    max-width: 1100px;
    align-items: start;
  }

  /* === Visualization wrapper === */
  .nn-viz-wrapper {
    position: relative;
    width: 100%;
    max-width: 900px;
    border-radius: 12px;
    overflow: hidden;
    background: rgba(255, 255, 255, 0.7);
    border: 1px solid rgba(8, 145, 178, 0.15);
  }

  /* === Black box overlay === */
  .nn-blackbox-overlay {
    position: absolute;
    inset: 0;
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 12px;
    overflow: hidden;
  }

  .nn-mask-svg {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
  }

  .nn-blackbox-label {
    font-size: 4rem;
    font-weight: 800;
    color: rgba(26, 46, 58, 0.2);
    user-select: none;
    letter-spacing: 0.05em;
    z-index: 1;
    transition: opacity 0.4s ease;
  }

  /* === SVG === */
  .nn-svg {
    display: block;
    width: 100%;
    height: auto;
    padding: 1rem;
  }

  /* === Layer labels === */
  .nn-layer-label {
    fill: #3d5a6a;
    font-size: 12px;
    font-weight: 600;
    font-family: 'Inter', system-ui, sans-serif;
    letter-spacing: 0.04em;
    text-transform: uppercase;
  }

  .nn-layer-sublabel {
    fill: #5a7a8a;
    font-size: 10px;
    font-family: 'Inter', system-ui, sans-serif;
  }

  .nn-block-label {
    fill: #3d5a6a;
    font-size: 13px;
    font-weight: 500;
    font-family: 'Inter', system-ui, sans-serif;
  }

  .nn-sublayer-label {
    fill: #3d5a6a;
    font-size: 11px;
    font-weight: 500;
    font-family: 'Inter', system-ui, sans-serif;
  }

  .nn-output-label {
    fill: #1a2e3a;
  }

  .nn-nx-label {
    fill: #0ea5e9;
    font-size: 22px;
    font-weight: 700;
    font-family: 'Inter', system-ui, sans-serif;
  }

  .nn-nx-sublabel {
    fill: #5a7a8a;
    font-size: 11px;
    font-family: 'Inter', system-ui, sans-serif;
  }

  /* === Token boxes === */
  .nn-token-box {
    fill: rgba(14, 165, 233, 0.08);
    stroke: rgba(14, 165, 233, 0.35);
    stroke-width: 1;
  }

  .nn-token-text {
    fill: #38bdf8;
    font-size: 13px;
    font-weight: 600;
    font-family: 'Inter', system-ui, sans-serif;
  }

  /* === Nodes === */
  .nn-node {
    stroke-width: 1.5;
    filter: url(#nn-glow);
  }

  .nn-node-embed {
    fill: rgba(14, 165, 233, 0.15);
    stroke: #0ea5e9;
  }

  .nn-node-attn {
    fill: rgba(14, 165, 233, 0.2);
    stroke: #38bdf8;
  }

  .nn-node-ffn {
    fill: rgba(139, 92, 246, 0.2);
    stroke: #8b5cf6;
  }

  /* === Connections === */
  .nn-connection {
    stroke: rgba(14, 165, 233, 0.18);
    stroke-width: 1;
  }

  .nn-connection.nn-internal {
    stroke: rgba(139, 92, 246, 0.15);
    stroke-width: 0.8;
  }

  .nn-output-conn {
    stroke: rgba(14, 165, 233, 0.3);
    stroke-width: 1;
  }

  .nn-attention-link {
    stroke: rgba(56, 189, 248, 0.25);
    stroke-width: 1.5;
    stroke-dasharray: 4 3;
  }

  /* === Block backgrounds === */
  .nn-block-bg {
    fill: rgba(14, 165, 233, 0.03);
    stroke: rgba(14, 165, 233, 0.12);
    stroke-width: 1;
    stroke-dasharray: 6 4;
  }

  .nn-attn-block {
    fill: url(#nn-attn-grad);
    stroke: rgba(14, 165, 233, 0.15);
    stroke-width: 0.8;
  }

  .nn-ffn-block {
    fill: url(#nn-ffn-grad);
    stroke: rgba(139, 92, 246, 0.15);
    stroke-width: 0.8;
  }

  /* === Output === */
  .nn-output-block {
    fill: rgba(16, 185, 129, 0.08);
    stroke: rgba(16, 185, 129, 0.3);
    stroke-width: 1;
  }

  .nn-prob-bar {
    fill: #0ea5e9;
  }

  .nn-prob-bar[data-nn-prob="0"] {
    fill: #00d4ff;
  }

  .nn-prob-text {
    fill: #3d5a6a;
    font-size: 10px;
    font-family: 'Inter', system-ui, sans-serif;
  }

  .nn-prob-heading {
    fill: #3d5a6a;
    font-size: 11px;
    font-weight: 600;
    font-family: 'Inter', system-ui, sans-serif;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  /* === Pulse animation (CSS fallback for non-GSAP) === */
  .nn-pulse {
    will-change: transform, opacity;
  }

  /* === Key panel === */
  .nn-key {
    position: sticky;
    top: 6rem;
    display: flex;
    flex-direction: column;
    gap: 0.85rem;
    padding: 1.25rem;
    background: rgba(255, 255, 255, 0.7);
    border: 1px solid rgba(8, 145, 178, 0.12);
    border-radius: 12px;
    opacity: 0;
  }

  .nn-key-title {
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: #5a7a8a;
    margin: 0 0 0.25rem;
  }

  .nn-key-item {
    display: flex;
    gap: 0.6rem;
    align-items: flex-start;
    opacity: 0.4;
    transition: opacity 0.4s ease;
  }

  .nn-key-item.active {
    opacity: 1;
  }

  .nn-key-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    flex-shrink: 0;
    margin-top: 2px;
  }

  .nn-key-dot--input { background: #0ea5e9; }
  .nn-key-dot--embed { background: #0ea5e9; }
  .nn-key-dot--attn { background: #38bdf8; }
  .nn-key-dot--ffn { background: #8b5cf6; }
  .nn-key-dot--output { background: #10b981; }

  .nn-key-label {
    display: block;
    font-size: 0.8rem;
    font-weight: 600;
    color: #1a2e3a;
    line-height: 1.3;
  }

  .nn-key-desc {
    display: block;
    font-size: 0.72rem;
    color: #5a7a8a;
    line-height: 1.4;
  }

  .nn-key-callout {
    margin-top: 0.5rem;
    padding: 0.75rem;
    background: rgba(8, 145, 178, 0.06);
    border: 1px solid rgba(8, 145, 178, 0.15);
    border-radius: 8px;
    opacity: 0;
    transition: opacity 0.4s ease;
  }

  .nn-key-callout strong {
    display: block;
    font-size: 0.8rem;
    color: #0891b2;
    margin-bottom: 0.3rem;
  }

  .nn-key-callout span {
    font-size: 0.72rem;
    color: #3d5a6a;
    line-height: 1.5;
  }

  /* === Reduced motion === */
  @media (prefers-reduced-motion: reduce) {
    .nn-pulse {
      display: none;
    }
    .nn-blackbox-label {
      transition: none;
    }
  }

  /* === Responsive === */
  @media (max-width: 768px) {
    .nn-layout {
      grid-template-columns: 1fr;
    }

    .nn-key {
      position: static;
      order: 2;
    }
  }

  @media (max-width: 640px) {
    .nn-section {
      padding: 2rem 1rem;
    }

    .nn-svg {
      padding: 0.5rem;
    }

    .nn-heading {
      font-size: 1.4rem;
    }

    .nn-blackbox-label {
      font-size: 2.5rem;
    }

    .nn-key {
      padding: 1rem;
    }

    .nn-key-callout {
      padding: 0.6rem;
    }
  }
</style>

<script>
  /**
   * NeuralNetworkSVG scroll animation orchestration.
   * Relies on gsap + ScrollTrigger being registered globally by Layout.astro.
   *
   * Uses ScrollTrigger.create + onUpdate with progress-based phase mapping
   * instead of scrubbed timeline with tl.call() (which doesn't reliably fire).
   *
   * Progress phases (0-1):
   *   0.00 - 0.10  Heading + description fade in
   *   0.10 - 0.25  Black box dissolves
   *   0.25 - 0.75  Layers reveal bottom-to-top (input, embedding, t1, t2, output)
   *   0.75 - 0.90  Output probability bars + connection line appear
   *   0.90 - 1.00  Data flow pulses start playing
   */
  function initNeuralNetwork() {
    const gsap = (window as any).gsap;
    const ScrollTrigger = (window as any).ScrollTrigger;
    if (!gsap || !ScrollTrigger) return;

    const section = document.getElementById('neural-network-section');
    if (!section) return;

    const heading = section.querySelector('[data-nn="heading"]') as HTMLElement;
    const desc = section.querySelector('[data-nn="desc"]') as HTMLElement;
    const blackbox = section.querySelector('[data-nn="blackbox"]') as HTMLElement;
    const blackboxLabel = section.querySelector('[data-nn="blackbox-label"]') as HTMLElement;
    const revealCircle = document.getElementById('nn-reveal-circle');
    const probBars = section.querySelectorAll('[data-nn-prob]');
    const probTexts = section.querySelectorAll('.nn-prob-text');
    const probHeading = section.querySelector('.nn-prob-heading');
    const outputConn = section.querySelector('.nn-output-conn');
    const pulses = section.querySelectorAll('.nn-pulse');

    const keyPanel = section.querySelector('[data-nn="key"]') as HTMLElement;
    const keyItems = {
      input: section.querySelector('[data-nn-key="input"]') as HTMLElement,
      embedding: section.querySelector('[data-nn-key="embedding"]') as HTMLElement,
      attention: section.querySelector('[data-nn-key="attention"]') as HTMLElement,
      ffn: section.querySelector('[data-nn-key="ffn"]') as HTMLElement,
      output: section.querySelector('[data-nn-key="output"]') as HTMLElement,
    };
    const keyCallout = section.querySelector('[data-nn-key="params"]') as HTMLElement;

    const layerOrder = ['input', 'embedding', 'transformer-1', 'transformer-2', 'output'];

    // Map layer names to which key items should highlight
    const layerToKeys: Record<string, string[]> = {
      'input': ['input'],
      'embedding': ['embedding'],
      'transformer-1': ['attention', 'ffn'],
      'transformer-2': ['attention', 'ffn'],
      'output': ['output'],
    };

    // State tracker to avoid redundant gsap.to() calls
    const reached: Record<string, boolean> = {};

    function once(key: string, fn: () => void) {
      if (!reached[key]) {
        reached[key] = true;
        fn();
      }
    }

    function unonce(key: string, fn: () => void) {
      if (reached[key]) {
        reached[key] = false;
        fn();
      }
    }

    // Set initial states (hidden)
    gsap.set([heading, desc], { opacity: 0, y: 20 });
    gsap.set(revealCircle, { attr: { r: 0 } });
    blackbox.style.pointerEvents = 'auto';

    // Build repeating pulse timelines (paused initially)
    const pulsePathY = [507, 466, 414, 332, 234, 152, 68];
    const pulsePathX = [300, 400, 500];
    const pulseTimelines: any[] = [];

    pulses.forEach((pulse, i) => {
      const xPos = pulsePathX[i] || pulsePathX[0];
      const pulseTl = gsap.timeline({ repeat: -1, delay: i * 0.6, paused: true });

      pulsePathY.forEach((yPos, j) => {
        if (j === 0) {
          pulseTl.set(pulse, { attr: { cx: xPos, cy: yPos }, opacity: 0.9 });
        } else {
          pulseTl.to(pulse, {
            attr: { cy: yPos },
            duration: 0.4,
            ease: 'power1.inOut',
          });
        }
      });
      pulseTl.to(pulse, { opacity: 0, duration: 0.2 });
      pulseTimelines.push(pulseTl);
    });

    ScrollTrigger.create({
      trigger: section,
      start: 'center center',
      end: '+=250%',
      pin: true,
      anticipatePin: 1,
      onUpdate: (self: any) => {
        const p = self.progress; // 0 to 1

        // --- Phase 1: heading + description (0.00 - 0.10) ---
        if (p >= 0.02) {
          once('heading', () => {
            gsap.to(heading, { opacity: 1, y: 0, duration: 0.5, ease: 'power2.out' });
          });
        } else {
          unonce('heading', () => {
            gsap.to(heading, { opacity: 0, y: 20, duration: 0.3 });
          });
        }

        if (p >= 0.05) {
          once('desc', () => {
            gsap.to(desc, { opacity: 1, y: 0, duration: 0.5, ease: 'power2.out' });
          });
        } else {
          unonce('desc', () => {
            gsap.to(desc, { opacity: 0, y: 20, duration: 0.3 });
          });
        }

        // --- Phase 2: black box iris reveal (0.10 - 0.25) ---
        if (p >= 0.10) {
          once('blackbox', () => {
            // Fade out the "?" label
            gsap.to(blackboxLabel, { opacity: 0, duration: 0.3, ease: 'power2.in' });
            // Expand the reveal circle
            gsap.to(revealCircle, {
              attr: { r: 600 },
              duration: 1.2,
              ease: 'power2.inOut',
              onComplete: () => { blackbox.style.pointerEvents = 'none'; },
            });
            // Reveal the key panel
            if (keyPanel) {
              gsap.to(keyPanel, { opacity: 1, duration: 0.6, delay: 0.3, ease: 'power2.out' });
            }
          });
        } else {
          unonce('blackbox', () => {
            // Shrink the circle back
            gsap.to(revealCircle, {
              attr: { r: 0 },
              duration: 0.6,
              ease: 'power2.in',
            });
            gsap.to(blackboxLabel, {
              opacity: 1,
              duration: 0.3,
              delay: 0.3,
              onComplete: () => { blackbox.style.pointerEvents = 'auto'; },
            });
            // Hide key panel
            if (keyPanel) {
              gsap.to(keyPanel, { opacity: 0, duration: 0.3 });
            }
            // Reset all key item highlights
            Object.values(keyItems).forEach(item => item?.classList.remove('active'));
            if (keyCallout) gsap.set(keyCallout, { opacity: 0 });
          });
        }

        // --- Phase 3: layers reveal bottom-to-top (0.25 - 0.75) ---
        // Each layer gets an equal slice of the 0.25-0.75 range
        const layerStart = 0.25;
        const layerEnd = 0.75;
        const layerRange = layerEnd - layerStart;
        const layerSlice = layerRange / layerOrder.length;

        layerOrder.forEach((layerName, i) => {
          const threshold = layerStart + i * layerSlice;
          const key = `layer-${layerName}`;
          const layerEls = section.querySelectorAll(`[data-nn-layer="${layerName}"]`);

          if (p >= threshold) {
            once(key, () => {
              gsap.to(layerEls, {
                opacity: 1,
                duration: 0.5,
                stagger: 0.05,
                ease: 'power2.out',
              });
              // Highlight corresponding key items
              const keysToHighlight = layerToKeys[layerName] || [];
              keysToHighlight.forEach(k => keyItems[k as keyof typeof keyItems]?.classList.add('active'));
            });
          } else {
            unonce(key, () => {
              gsap.to(layerEls, { opacity: 0, duration: 0.3 });
              // Remove highlight from corresponding key items
              const keysToRemove = layerToKeys[layerName] || [];
              keysToRemove.forEach(k => keyItems[k as keyof typeof keyItems]?.classList.remove('active'));
            });
          }
        });

        // --- Phase 4: output probabilities (0.75 - 0.90) ---
        if (p >= 0.75) {
          once('output-conn', () => {
            gsap.to(outputConn, { opacity: 1, duration: 0.4, ease: 'power2.out' });
          });
        } else {
          unonce('output-conn', () => {
            gsap.to(outputConn, { opacity: 0, duration: 0.3 });
          });
        }

        if (p >= 0.78) {
          once('prob-heading', () => {
            gsap.to(probHeading, { opacity: 1, duration: 0.4, ease: 'power2.out' });
          });
        } else {
          unonce('prob-heading', () => {
            gsap.to(probHeading, { opacity: 0, duration: 0.3 });
          });
        }

        if (p >= 0.80) {
          once('prob-bars', () => {
            gsap.to(probBars, { opacity: 1, duration: 0.4, stagger: 0.08, ease: 'power2.out' });
          });
        } else {
          unonce('prob-bars', () => {
            gsap.to(probBars, { opacity: 0, duration: 0.3 });
          });
        }

        if (p >= 0.83) {
          once('prob-texts', () => {
            gsap.to(probTexts, { opacity: 1, duration: 0.4, stagger: 0.08 });
          });
        } else {
          unonce('prob-texts', () => {
            gsap.to(probTexts, { opacity: 0, duration: 0.3 });
          });
        }

        // --- Phase 5: data flow pulses (0.90+) ---
        if (p >= 0.90) {
          once('pulses', () => {
            pulseTimelines.forEach((ptl) => ptl.play());
          });
          // Show params callout
          once('params-callout', () => {
            if (keyCallout) gsap.to(keyCallout, { opacity: 1, duration: 0.5, ease: 'power2.out' });
          });
        } else {
          unonce('pulses', () => {
            pulseTimelines.forEach((ptl) => {
              ptl.pause();
              ptl.progress(0);
            });
            gsap.set(pulses, { opacity: 0 });
          });
          unonce('params-callout', () => {
            if (keyCallout) gsap.to(keyCallout, { opacity: 0, duration: 0.3 });
          });
        }
      },
    });
  }

  // Initialize when DOM and GSAP are ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      requestAnimationFrame(initNeuralNetwork);
    });
  } else {
    requestAnimationFrame(initNeuralNetwork);
  }
</script>
